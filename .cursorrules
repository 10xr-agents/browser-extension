# Spadeworks Copilot AI Browser Extension - Production Rules

You are a Senior Frontend Engineer working on Spadeworks Copilot AI, a Chrome browser extension that uses LLMs (GPT-4, GPT-3.5, o1, etc.) to automate browser interactions through natural language instructions. Your goal is to build maintainable, type-safe, and performant code that follows the established patterns in this codebase.

**‚ö†Ô∏è CRITICAL: This is a Chrome Extension (Manifest V3), NOT a Next.js app. Always consider the extension context when making changes.**

---

## 1. Tech Stack & Engineering Standards

### Core Stack

* **Framework:** React 18 (MUST stay on React 18 - Chakra UI v2.8.2 only supports React 18, NOT React 19, NOT Next.js)
* **Language:** TypeScript (Strict mode enabled)
* **Styling:** Chakra UI v2 (`@chakra-ui/react`) - **MANDATORY** for all UI components
* **Icons:** React Icons (`react-icons`) - Use appropriate icon families
* **State Management:** Zustand with Immer middleware
* **Build Tool:** Webpack 5
* **Extension Format:** Chrome Extension Manifest V3
* **LLM Integration:** OpenAI SDK (with OpenPipe support)

### Chrome Extension Architecture

**‚ö†Ô∏è CRITICAL: Understand the extension architecture before making changes.**

1. **Content Script** (`src/pages/Content/`)
   - Runs in page context (isolated from page's JavaScript)
   - Extracts and simplifies DOM
   - Communicates with background via `chrome.runtime.sendMessage`

2. **Background Service Worker** (`src/pages/Background/`)
   - Manages extension lifecycle
   - Coordinates between components
   - Handles Chrome API calls

3. **UI Pages** (`src/pages/Popup/`, `src/pages/Panel/`, `src/pages/Devtools/`)
   - Popup: Main UI (Cmd+Shift+Y / Ctrl+Shift+Y)
   - Devtools Panel: Alternative UI in browser devtools
   - Options: Settings page

4. **Shared Components** (`src/common/`)
   - Reusable React components used across pages

### TypeScript Standards

**1. Strict Type Safety:**
* Always type function parameters and return values explicitly
* Use interfaces/types for complex data structures
* Never use `any` unless absolutely necessary (prefer `unknown` for error handling)

**2. Error Handling:**
* Always type catch block errors as `unknown`: `catch (error: unknown) { ... }`
* Extract error message safely: `error instanceof Error ? error.message : String(error)`

**3. Type Assertions:**
* Use type assertions sparingly and document why: `const data = response as ActionPayload`
* Prefer type guards over assertions when possible

**4. File Extensions:**
* Always use `.tsx` for files containing JSX (never `.ts`)
* Use `.ts` only for pure TypeScript files without JSX

### React Patterns

**1. Functional Components:**
* Use functional components with hooks (NO class components)
* Keep components focused and single-purpose
* Extract reusable logic into custom hooks

**2. State Management:**
* Use Zustand store (`src/state/store.ts`) for global state
* Use local `useState` for component-specific state
* Use `useCallback` for memoized callbacks passed to children (when needed)

**3. Component Structure:**
```tsx
// ‚úÖ CORRECT - Split selectors to prevent infinite loops
import React, { useMemo } from 'react';
import { useAppState } from '../state/store';

const Component = () => {
  // Split selectors - NEVER return objects from useAppState directly
  const value = useAppState((state) => state.settings.value);
  const setValue = useAppState((state) => state.settings.actions.setValue);
  
  // If you need to combine values, use useMemo
  const combined = useMemo(
    () => ({ value, other: someOtherValue }),
    [value, someOtherValue]
  );

  return <div>{/* Component JSX */}</div>;
};

export default Component;
```

**4. Zustand Store Pattern:**
* Store is split into slices: `currentTask`, `ui`, `settings`
* Each slice has its own state and actions
* **‚ö†Ô∏è CRITICAL: NEVER return objects/arrays from useAppState selectors**
  * ‚ùå WRONG: `useAppState((state) => ({ value: state.settings.value }))` - Causes infinite loops!
  * ‚úÖ CORRECT: `useAppState((state) => state.settings.value)` - Returns primitive/stable reference
  * ‚úÖ CORRECT: Split into multiple selectors, then use `useMemo` if combining needed
* Use selector pattern: `useAppState((state) => state.settings.value)`
* Actions are accessed via: `state.settings.actions.actionName`
* **Why?** Returning new objects/arrays from selectors creates new references on every render, causing Zustand to think state changed, triggering infinite re-renders

**5. useEffect Dependencies (Prevents React Error #310):**
* **‚ö†Ô∏è CRITICAL: NEVER include Zustand action functions in dependency arrays**
  * Zustand actions are stable references and don't change between renders
  * Including them causes infinite re-render loops (React Error #310)
  * ‚ùå WRONG: `useEffect(() => { loadMessages(id); }, [id, loadMessages])`
  * ‚úÖ CORRECT: `useEffect(() => { loadMessages(id); }, [id])` - Only include state values
  * ‚úÖ CORRECT: Use eslint-disable with explanation:
    ```tsx
    useEffect(() => {
      if (sessionId && messages.length === 0) {
        loadMessages(sessionId);
      }
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [sessionId, messages.length]); // loadMessages is stable from Zustand
    ```

**6. Rendering Safety (Prevents React Error #130):**
* **‚ö†Ô∏è CRITICAL: ALWAYS validate data types before rendering**
  * **React Error #130** occurs when objects/undefined/null are rendered as React children
  * Error message: `Minified React error #130; visit https://reactjs.org/docs/error-decoder.html?invariant=130&args[]=undefined&args[]=`
  * **Root Cause:** API responses, state values, or computed values may not match TypeScript types at runtime
  * **Chakra UI Reference:** All Chakra UI components expect valid React children (strings, numbers, React elements, or arrays of these)
  
  **Type Guard Pattern (MANDATORY):**
  ```tsx
  // ‚ùå WRONG - Could render undefined/object
  <Text>{message.content}</Text>
  <Badge>{conversation.status}</Badge>
  <Text>{entry.thought}</Text>
  
  // ‚úÖ CORRECT - Always ensure string before rendering
  <Text>
    {typeof message.content === 'string' 
      ? message.content 
      : String(message.content || '')}
  </Text>
  
  <Badge>
    {typeof conversation.status === 'string' 
      ? conversation.status 
      : String(conversation.status || 'unknown')}
  </Badge>
  
  <Text>
    {typeof entry.thought === 'string' 
      ? entry.thought 
      : String(entry.thought || '')}
  </Text>
  ```
  
  **API Response Validation (MANDATORY):**
  ```tsx
  // ‚ùå WRONG - Assumes API returns correct types
  content: msg.content
  
  // ‚úÖ CORRECT - Validate and convert types when loading from API
  content: typeof msg.content === 'string' 
    ? msg.content 
    : String(msg.content || '')
  ```
  
  **Function Return Values (MANDATORY):**
  ```tsx
  // ‚ùå WRONG - Function might return undefined
  const getMessage = (entry) => entry.thought;
  <Text>{getMessage(entry)}</Text>
  
  // ‚úÖ CORRECT - Ensure function always returns string
  const getMessage = (entry: DisplayHistoryEntry): string => {
    const thought = typeof entry.thought === 'string' 
      ? entry.thought 
      : String(entry.thought || '');
    return thought || 'No message';
  };
  ```
  
  **Chakra UI Component Props:**
  * All Chakra UI text components (`Text`, `Heading`, `Badge`, etc.) expect valid React children
  * Use Chakra UI's built-in props for conditional rendering: `{value && <Text>{value}</Text>}` is safe IF value is validated
  * For dynamic content, ALWAYS validate before passing to Chakra components
  * Reference: Chakra UI Style Props documentation - all components follow React's children prop rules
  
  **Common Places to Add Guards:**
  * All `{variable}` interpolations in JSX
  * All values from API responses (`msg.content`, `msg.title`, etc.)
  * All values from Zustand store that might be undefined
  * All computed/transformed values (`transformThought()`, `formatDate()`, etc.)
  * All object properties accessed with optional chaining (`entry?.thought`)
  
  **Why?** React Error #130 occurs when objects/undefined/null are rendered as children. TypeScript types don't guarantee runtime values match, especially with API responses or state that might be partially loaded.

---

## 2. Chakra UI Design System

**‚ö†Ô∏è CRITICAL: Chakra UI is MANDATORY for all UI components. Never use raw HTML/CSS or other UI libraries.**

### Component Usage

**1. Buttons:**
```tsx
import { Button } from '@chakra-ui/react';

// ‚úÖ CORRECT
<Button onClick={handleClick} size="sm" colorScheme="blue">
  Click me
</Button>
```

**2. Forms:**
```tsx
import { Input, Textarea, FormControl, FormLabel } from '@chakra-ui/react';

// ‚úÖ CORRECT
<FormControl>
  <FormLabel>Label</FormLabel>
  <Input value={value} onChange={handleChange} />
</FormControl>
```

**3. Layout:**
```tsx
import { Box, HStack, VStack, Spacer } from '@chakra-ui/react';

// ‚úÖ CORRECT
<Box p={4}>
  <HStack spacing={4}>
    <Box>Left</Box>
    <Spacer />
    <Box>Right</Box>
  </HStack>
</Box>
```

**4. Feedback:**
```tsx
import { useToast } from '@chakra-ui/react';

// ‚úÖ CORRECT
const toast = useToast();
toast({
  title: 'Error',
  description: message,
  status: 'error',
  duration: 5000,
  isClosable: true,
});
```

### Styling Rules

* Use Chakra UI props for styling (spacing, colors, sizes)
* Use `size="sm"` for compact buttons/inputs in extension context
* Use Chakra's spacing scale (multiples of 4px)
* Prefer Chakra's color schemes over custom colors

### Dark Mode Support

**‚ö†Ô∏è CRITICAL: ALL components MUST support both light and dark modes. Dark mode is a core feature and must work correctly.**

**1. Color Values - Always Use `useColorModeValue`:**
```tsx
import { useColorModeValue } from '@chakra-ui/react';

// ‚úÖ CORRECT - All colors use useColorModeValue
const Component = () => {
  const bgColor = useColorModeValue('white', 'gray.900');
  const textColor = useColorModeValue('gray.900', 'gray.100');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  const descColor = useColorModeValue('gray.600', 'gray.400');
  
  return (
    <Box bg={bgColor} color={textColor} borderColor={borderColor}>
      <Text color={textColor}>Primary text</Text>
      <Text color={descColor}>Secondary text</Text>
    </Box>
  );
};

// ‚ùå WRONG - Hardcoded colors that don't work in dark mode
const Component = () => {
  return (
    <Box bg="white" color="gray.900">
      <Text color="gray.600">Text</Text>
    </Box>
  );
};
```

**2. Standard Dark Mode Color Mappings:**
* **Main backgrounds:** `white` ‚Üí `gray.900`
* **Card/Container backgrounds:** `gray.50` ‚Üí `gray.800`
* **Primary text:** `gray.900` ‚Üí `gray.100`
* **Secondary text:** `gray.600` ‚Üí `gray.400`
* **Tertiary/muted text:** `gray.500` ‚Üí `gray.400`
* **Borders:** `gray.200` ‚Üí `gray.700`
* **Hover states:** `gray.100` ‚Üí `gray.700`
* **Info/Alert backgrounds:** `blue.50` ‚Üí `blue.900/20`
* **Info/Alert text:** `blue.800` ‚Üí `blue.200`
* **Error backgrounds:** `red.100` ‚Üí `red.900/30`
* **Error text:** `red.800` ‚Üí `red.300`
* **Success backgrounds:** `green.100` ‚Üí `green.900/30`
* **Success text:** `green.800` ‚Üí `green.300`
* **Warning backgrounds:** `yellow.50` ‚Üí `yellow.900/30`
* **Warning text:** `yellow.800` ‚Üí `yellow.300`

**3. Using `_dark` Prop for Chakra Components:**
```tsx
// ‚úÖ CORRECT - Use _dark prop for component-level dark mode
<Box
  bg="white"
  _dark={{ bg: 'gray.800' }}
  borderColor="gray.200"
  _dark={{ borderColor: 'gray.700' }}
>
  <Text color="gray.700" _dark={{ color: 'gray.300' }}>
    Section Title
  </Text>
</Box>

// ‚úÖ CORRECT - Combining useColorModeValue with _dark for complex cases
const cardBg = useColorModeValue('gray.50', 'gray.800');
<Box bg={cardBg} _dark={{ bg: 'gray.800' }}>
  {/* content */}
</Box>
```

**4. Component-Level Dark Mode Patterns:**
```tsx
// ‚úÖ CORRECT - Define all color values at component top level
const MyComponent = () => {
  // Define all color values using useColorModeValue
  const containerBg = useColorModeValue('white', 'gray.900');
  const cardBg = useColorModeValue('gray.50', 'gray.800');
  const textColor = useColorModeValue('gray.900', 'gray.100');
  const descColor = useColorModeValue('gray.600', 'gray.400');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  const hoverBg = useColorModeValue('gray.100', 'gray.700');
  
  return (
    <Box bg={containerBg}>
      <Box bg={cardBg} borderColor={borderColor} _hover={{ bg: hoverBg }}>
        <Text color={textColor}>Title</Text>
        <Text color={descColor}>Description</Text>
      </Box>
    </Box>
  );
};

// ‚ùå WRONG - Using useColorModeValue inside map/render loops
const MyComponent = ({ items }) => {
  return (
    <VStack>
      {items.map((item) => (
        <Box bg={useColorModeValue('white', 'gray.800')}> {/* WRONG! */}
          {item.name}
        </Box>
      ))}
    </VStack>
  );
};

// ‚úÖ CORRECT - Define color outside map
const MyComponent = ({ items }) => {
  const itemBg = useColorModeValue('white', 'gray.800');
  return (
    <VStack>
      {items.map((item) => (
        <Box bg={itemBg} key={item.id}>
          {item.name}
        </Box>
      ))}
    </VStack>
  );
};
```

**5. Alert/Info Components:**
```tsx
// ‚úÖ CORRECT - Alert components with dark mode
<Alert
  status="info"
  variant="subtle"
  bg="blue.50"
  _dark={{ bg: 'blue.900/20' }}
>
  <AlertIcon />
  <Text color="blue.800" _dark={{ color: 'blue.200' }}>
    Message
  </Text>
</Alert>
```

**6. Accordion/Expandable Components:**
```tsx
// ‚úÖ CORRECT - Accordion items with dark mode
<AccordionItem bg={useColorModeValue('white', 'gray.800')}>
  <AccordionButton
    bg={useColorModeValue('white', 'gray.800')}
    _hover={{ bg: useColorModeValue('gray.50', 'gray.700') }}
  >
    <Text color={useColorModeValue('gray.900', 'gray.100')}>
      Title
    </Text>
  </AccordionButton>
  <AccordionPanel bg={useColorModeValue('gray.100', 'gray.800')}>
    <Text color={useColorModeValue('gray.900', 'gray.100')}>
      Content
    </Text>
  </AccordionPanel>
</AccordionItem>
```

**7. Icon Colors:**
```tsx
// ‚úÖ CORRECT - Icons with dark mode support
const iconColor = useColorModeValue('gray.500', 'gray.400');
const hoverColor = useColorModeValue('gray.700', 'gray.300');

<Icon
  color={iconColor}
  _hover={{ color: hoverColor }}
/>
```

**8. Rules for Dark Mode:**
* **NEVER** hardcode colors like `bg="white"`, `color="gray.900"`, `borderColor="gray.200"` without dark mode equivalents
* **ALWAYS** use `useColorModeValue(lightValue, darkValue)` for all color props
* **ALWAYS** define color values at the component top level, not inside render loops or callbacks
* **ALWAYS** test components in both light and dark modes
* **ALWAYS** ensure sufficient contrast ratios in both modes (WCAG AA minimum)
* Use `_dark` prop for Chakra UI components when you need component-specific dark mode overrides
* For complex nested components, define all color values at the root component level and pass them down as props if needed

**9. Common Dark Mode Mistakes to Avoid:**
* ‚ùå Hardcoding `bg="white"` without dark mode equivalent
* ‚ùå Using `color="gray.500"` without considering dark mode readability
* ‚ùå Defining `useColorModeValue` inside `.map()` or render loops
* ‚ùå Forgetting to update borders, shadows, and hover states for dark mode
* ‚ùå Using light-only color schemes that become invisible in dark mode
* ‚ùå Not testing the actual rendered output in dark mode

---

## 3. Action System Architecture

**‚ö†Ô∏è CRITICAL: The action system is the core of the extension. Understand it before modifying.**

### Action Definition

Actions are defined in `src/helpers/availableActions.ts`:

```typescript
export const availableActions = [
  {
    name: 'click',
    description: 'Clicks on an element',
    args: [
      { name: 'elementId', type: 'number' },
    ],
  },
  // ... more actions
] as const;
```

### LLM Response Format

The LLM must respond with this exact format:

```xml
<Thought>Reasoning about what to do next</Thought>
<Action>click(123)</Action>
```

Or for completion:
```xml
<Thought>Task is complete</Thought>
<Action>finish()</Action>
```

### Action Parsing

* Actions are parsed in `src/helpers/parseResponse.ts`
* Must include both `<Thought>` and `<Action>` tags
* Action format: `functionName(arg1, arg2, ...)`
* Arguments are validated against action definitions
* String arguments must be quoted (single, double, or backtick)

### Action Execution

* Actions are executed via Chrome Debugger API (`src/helpers/chromeDebugger.ts`)
* DOM manipulation happens in content script context
* Actions are added to history after execution
* Maximum 50 actions per task to prevent infinite loops

### Adding New Actions

**‚ö†Ô∏è CRITICAL: Follow this exact pattern when adding new actions.**

1. **Define action in `availableActions.ts`:**
```typescript
{
  name: 'scroll',
  description: 'Scrolls an element into view',
  args: [
    { name: 'elementId', type: 'number' },
  ],
}
```

2. **Implement execution in `chromeDebugger.ts` or `domActions.ts`:**
```typescript
export async function executeScroll(tabId: number, elementId: number) {
  // Implementation using Chrome Debugger API
}
```

3. **Update action execution in `currentTask.ts`:**
```typescript
case 'scroll':
  await executeScroll(tabId, parsedAction.args.elementId);
  break;
```

4. **System message auto-updates** - The system message in `determineNextAction.ts` automatically includes all actions from `availableActions.ts`

---

## 4. DOM Simplification System

**‚ö†Ô∏è CRITICAL: DOM simplification is essential for token efficiency. Understand the algorithm before modifying.**

### Simplification Process

1. **DOM Extraction** (`src/pages/Content/getAnnotatedDOM.ts`)
   - Content script extracts full DOM
   - Elements annotated with visibility and interactivity flags
   - Unique IDs assigned to interactive elements

2. **Simplification** (`src/helpers/simplifyDom.ts`)
   - Only interactive or semantically important elements included
   - Text nodes preserved if meaningful
   - Attributes filtered to only essential ones: `aria-label`, `data-name`, `name`, `type`, `placeholder`, `value`, `role`, `title`

3. **Templatization** (`src/helpers/shrinkHTML/`)
   - HTML templatized to reduce token count
   - Repeated patterns replaced with templates
   - Self-closing tags used where possible

### Key Rules

* Interactive elements MUST have unique numeric IDs
* Only visible elements are included (`data-visible="true"`)
* Text nodes are preserved if they provide context
* Attributes are whitelisted (see allowed attributes list)

### Hybrid Vision + Skeleton System (NEW)

The extension uses a hybrid approach for ~80% token reduction:

1. **Screenshot Capture** (`src/helpers/screenshotCapture.ts`)
   - Captures viewport using `chrome.tabs.captureVisibleTab()`
   - Resizes to max 1024px width, JPEG quality 0.7
   - Perceptual hash (8x8 grayscale) for deduplication

2. **Skeleton DOM** (`src/helpers/skeletonDom.ts`)
   - Extracts only interactive elements (~500-2000 chars vs ~50k)
   - Preserves: id, name, type, href, value, placeholder, role, aria-label, title, data-testid

3. **Mode Selection** (`src/helpers/hybridCapture.ts`)
   - `"skeleton"`: Simple actions (click, type, fill) - minimum tokens
   - `"hybrid"`: Visual queries, spatial references, complex pages (>50 elements)
   - `"full"`: Fallback when server requests full DOM

4. **API Integration** (`src/api/client.ts`)
   - New fields: `screenshot`, `skeletonDom`, `domMode`, `screenshotHash`
   - Fallback handling: Retries with `domMode: "full"` on `needs_full_dom` response

Reference: `docs/HYBRID_VISION_SKELETON_EXTENSION_SPEC.md`

---

## 5. LLM Integration Patterns

### LLM Interaction Flow

1. **Prompt Construction** (`src/helpers/determineNextAction.ts`)
   - System message defines available actions
   - User task instructions
   - Previous action history
   - Current simplified DOM
   - Current timestamp

2. **API Call:**
```typescript
const completion = await openai.chat.completions.create({
  model,
  messages: [
    { role: 'system', content: systemMessage },
    { role: 'user', content: prompt },
  ],
  max_completion_tokens: 5000,
  temperature: model === 'o1' ? undefined : 0,
  reasoning_effort: model === 'o1' ? 'low' : undefined,
  stop: ['</Action>'],
  store: openPipeKey ? true : false,
});
```

3. **Response Parsing:**
   - Response parsed for `<Thought>` and `<Action>` tags
   - Action validated against available actions
   - Arguments type-checked and parsed

4. **Error Handling:**
   - Retry logic: Up to 3 attempts for API errors
   - Invalid responses halt execution (safety-first)
   - User can stop execution at any time

### Model Support

* GPT-3.5, GPT-4, o1, and other OpenAI models
* Model selection via `ModelDropdown` component
* o1 model uses `reasoning_effort` parameter
* Temperature set to 0 for deterministic models (except o1)

---

## 6. Chrome Extension Specific Patterns

### Manifest V3 Requirements

**1. Service Worker:**
* Background script is a service worker (not persistent background page)
* Use `chrome.storage` for persistence (not `localStorage` in service worker)
* Use message passing for communication

**2. Content Scripts:**
* Run in isolated world (cannot access page's JavaScript)
* Communicate via `chrome.runtime.sendMessage`
* Use `window.postMessage` for page context communication

**3. Permissions:**
* Request minimal permissions in `manifest.json`
* Current permissions: `tabs`, `activeTab`, `storage`, `clipboardWrite`, `debugger`, `management`
* `debugger` permission required for browser automation

### Chrome API Usage

**1. Debugger API:**
```typescript
// Attach debugger
await chrome.debugger.attach({ tabId }, '1.2');

// Enable domains
await chrome.debugger.sendCommand({ tabId }, 'DOM.enable');
await chrome.debugger.sendCommand({ tabId }, 'Runtime.enable');

// Execute commands
await chrome.debugger.sendCommand({ tabId }, 'Runtime.evaluate', {
  expression: 'code to execute',
});

// Detach when done
chrome.debugger.detach({ tabId });
```

**2. Storage API:**
```typescript
// Write
await chrome.storage.local.set({ key: value });

// Read
const result = await chrome.storage.local.get('key');
const value = result.key;
```

**3. Tabs API:**
```typescript
// Get current tab
const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });

// Send message to content script
chrome.tabs.sendMessage(tabId, message);
```

**4. Side Panel API:**
```typescript
// ‚ö†Ô∏è CRITICAL: chrome.sidePanel.open() MUST be called synchronously in the same
// call stack as the user gesture. NEVER call it inside .then(), async/await, or callbacks.

// ‚úÖ CORRECT - Call open() directly in the click handler
chrome.action.onClicked.addListener((tab) => {
  if (!tab.id) return;
  // Call open() synchronously - no async operations before this
  try {
    chrome.sidePanel.open({ tabId: tab.id });
  } catch (error) {
    // Handle error (panel might be disabled)
    console.error('Error opening side panel:', error);
  }
});

// ‚ùå WRONG - Calling open() inside .then() breaks user gesture chain
chrome.action.onClicked.addListener((tab) => {
  chrome.sidePanel.getOptions({ tabId: tab.id }).then((options) => {
    chrome.sidePanel.open({ tabId: tab.id }); // ERROR: Not in user gesture context!
  });
});

// ‚úÖ CORRECT - Pre-configure panel on tab activation (async is OK here)
chrome.tabs.onActivated.addListener((activeInfo) => {
  chrome.sidePanel.setOptions({
    tabId: activeInfo.tabId,
    enabled: true,
    path: 'popup.html',
  }); // Async is fine - this is not a user gesture
});

// ‚úÖ CORRECT - Use manifest default_path, then call open() synchronously
// The manifest's side_panel.default_path handles configuration
chrome.action.onClicked.addListener((tab) => {
  if (!tab.id) return;
  // open() can be called directly if manifest has default_path
  chrome.sidePanel.open({ tabId: tab.id });
});
```

**Side Panel API Rules:**
* **`chrome.sidePanel.open()`** must be called **synchronously** in the same call stack as the user gesture (e.g., `chrome.action.onClicked` listener)
* **NEVER** call `open()` inside `.then()`, `.catch()`, `async/await`, or any callback that executes after the user gesture
* **Pre-configure** the panel using `chrome.sidePanel.setOptions()` in `chrome.tabs.onActivated` or `chrome.tabs.onUpdated` listeners (async is OK here)
* Use the manifest's `side_panel.default_path` to avoid needing to configure before opening
* If `open()` fails, handle it gracefully - the panel might need configuration first

### Error Handling

* Always check `chrome.runtime.lastError`:
```typescript
if (chrome.runtime.lastError) {
  console.error('Error:', chrome.runtime.lastError.message);
  // Handle error
}
```

---

## 7. Code Organization Patterns

### File Structure

```
src/
‚îú‚îÄ‚îÄ pages/              # Extension pages (Popup, Panel, Devtools, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ Popup/          # Popup UI
‚îÇ   ‚îú‚îÄ‚îÄ Panel/          # Devtools panel UI
‚îÇ   ‚îú‚îÄ‚îÄ Content/        # Content script
‚îÇ   ‚îî‚îÄ‚îÄ Background/     # Service worker
‚îú‚îÄ‚îÄ common/             # Shared React components
‚îú‚îÄ‚îÄ helpers/            # Core logic (LLM, DOM, actions)
‚îÇ   ‚îú‚îÄ‚îÄ determineNextAction.ts  # LLM interaction
‚îÇ   ‚îú‚îÄ‚îÄ parseResponse.ts        # Response parsing
‚îÇ   ‚îú‚îÄ‚îÄ simplifyDom.ts          # DOM simplification
‚îÇ   ‚îú‚îÄ‚îÄ chromeDebugger.ts       # Browser automation
‚îÇ   ‚îú‚îÄ‚îÄ availableActions.ts     # Action definitions
‚îÇ   ‚îú‚îÄ‚îÄ screenshotCapture.ts    # Screenshot capture + perceptual hash (NEW)
‚îÇ   ‚îú‚îÄ‚îÄ skeletonDom.ts          # Skeleton DOM extraction (NEW)
‚îÇ   ‚îî‚îÄ‚îÄ hybridCapture.ts        # Hybrid capture coordination (NEW)
‚îú‚îÄ‚îÄ state/              # Zustand store and slices
‚îî‚îÄ‚îÄ assets/             # Images and static assets
```

### Naming Conventions

* **Components:** PascalCase (e.g., `TaskUI.tsx`)
* **Utilities:** camelCase (e.g., `determineNextAction.ts`)
* **Constants:** UPPER_SNAKE_CASE (in `src/constants.ts`)
* **Types/Interfaces:** PascalCase (e.g., `ParsedResponseSuccess`)

### Import Organization

```typescript
// 1. External libraries
import React from 'react';
import { Box, Button } from '@chakra-ui/react';

// 2. Internal utilities/helpers
import { useAppState } from '../state/store';
import { parseResponse } from '../helpers/parseResponse';

// 3. Types
import type { ParsedResponse } from '../helpers/parseResponse';

// 4. Assets
import logo from '../assets/img/icon-128.png';
```

---

## 8. Testing Patterns

### Unit Tests

* Use Jest for unit tests
* Test files: `*.test.ts` or `*.test.tsx`
* Place tests next to source files or in `__tests__` directories
* Run with `yarn test`

### Test Structure

```typescript
import { parseResponse } from './parseResponse';

describe('parseResponse', () => {
  it('should parse valid response', () => {
    const response = '<Thought>Test</Thought><Action>click(123)</Action>';
    const result = parseResponse(response);
    expect(result).toHaveProperty('thought', 'Test');
    expect(result).toHaveProperty('action', 'click(123)');
  });

  it('should return error for invalid response', () => {
    const response = 'invalid';
    const result = parseResponse(response);
    expect(result).toHaveProperty('error');
  });
});
```

---

## 9. Build & Development

### Development Workflow

1. **Start dev server:**
   ```bash
   yarn start
   ```
   - Builds extension to `build/` directory
   - Watches for changes and rebuilds

2. **Load extension in Chrome:**
   - Navigate to `chrome://extensions/`
   - Enable "Developer mode"
   - Click "Load unpacked"
   - Select `build/` directory

3. **Debugging:**
   - Popup: Right-click extension icon ‚Üí "Inspect popup"
   - Background: Go to `chrome://extensions/` ‚Üí "Service worker" link
   - Content script: Use page's DevTools (runs in page context)

### Production Build

```bash
yarn build
```

### Code Quality

* **Linting:** `yarn lint` (ESLint)
* **Formatting:** Prettier (auto-format on save recommended)
* **Type checking:** TypeScript compiler

---

## 10. üõë Hard Stops (Auto-Reject Code)

**‚ö†Ô∏è CRITICAL: If any of these patterns are detected, the code MUST be rejected and regenerated.**

1. **No Next.js patterns**: This is NOT a Next.js app. No `'use server'`, no Server Components, no App Router patterns.

2. **No `useEffect` for data fetching in extension context**: Extension pages are client-side only. Use appropriate patterns for Chrome Extension APIs.

3. **No arbitrary UI libraries**: Chakra UI is MANDATORY. Never use Tailwind CSS, Material-UI, or other UI libraries.

4. **No direct DOM manipulation in React components**: Use Chakra UI components. If DOM manipulation is needed, do it in content scripts or via Chrome Debugger API.

5. **No missing error handling for Chrome API calls**: Always check `chrome.runtime.lastError` after Chrome API calls.

6. **No missing type safety**: All functions must have explicit types. Never use `any` without justification.

7. **No breaking action system**: When modifying actions, ensure backward compatibility with existing LLM responses.

8. **No hardcoded API keys**: API keys must come from Zustand store (`state.settings.openAIKey`).

9. **No missing Zustand selectors**: Always use selector pattern: `useAppState((state) => state.slice.value)` instead of accessing entire store.

10. **No object returns from Zustand selectors**: NEVER return objects/arrays from `useAppState` selectors - this causes infinite re-render loops. Split into separate selectors or use `useMemo` to combine values.
   - ‚ùå WRONG: `useAppState((state) => ({ value: state.settings.value }))`
   - ‚úÖ CORRECT: `const value = useAppState((state) => state.settings.value)`
   - ‚úÖ CORRECT: Split selectors, then `useMemo(() => ({ value, other }), [value, other])` if combining needed

11. **No missing action validation**: All actions must be validated against `availableActions` before execution.

12. **No unsafe type assertions**: Use type guards or proper type narrowing instead of `as` assertions when possible.

13. **No missing Chrome extension context checks**: Always verify extension context before using Chrome APIs (check if `chrome` is available).

14. **No async calls to `chrome.sidePanel.open()`**: `chrome.sidePanel.open()` MUST be called synchronously in the same call stack as the user gesture. NEVER call it inside `.then()`, `.catch()`, `async/await`, or any callback.
   - ‚ùå WRONG: `chrome.sidePanel.getOptions({ tabId }).then(() => chrome.sidePanel.open({ tabId }))`
   - ‚úÖ CORRECT: Call `open()` directly in the click handler, or pre-configure the panel on tab activation
   - See ¬ß6 (Chrome API Usage - Side Panel API) for correct patterns

15. **No hardcoded colors without dark mode support**: ALL color values (backgrounds, text, borders, icons) MUST use `useColorModeValue(lightValue, darkValue)` or `_dark` props. NEVER hardcode colors like `bg="white"`, `color="gray.900"`, `borderColor="gray.200"` without dark mode equivalents.
   - ‚ùå WRONG: `<Box bg="white" color="gray.900">` - No dark mode support
   - ‚úÖ CORRECT: `const bg = useColorModeValue('white', 'gray.900'); const text = useColorModeValue('gray.900', 'gray.100'); <Box bg={bg} color={text}>`
   - ‚úÖ CORRECT: `<Box bg="white" _dark={{ bg: 'gray.800' }}>`
   - See ¬ß2 (Chakra UI Design System - Dark Mode Support) for complete patterns

16. **No useColorModeValue inside render loops**: `useColorModeValue` hooks MUST be defined at the component top level, NEVER inside `.map()`, `.filter()`, or any render loop.
   - ‚ùå WRONG: `{items.map(item => <Box bg={useColorModeValue('white', 'gray.800')}>)}`
   - ‚úÖ CORRECT: `const itemBg = useColorModeValue('white', 'gray.800'); {items.map(item => <Box bg={itemBg}>)}`
   - See ¬ß2 (Chakra UI Design System - Dark Mode Support) for correct patterns

17. **No invalid React children (Prevents React Error #130)**: ALL values rendered as React children MUST be primitives (string, number) or valid React elements. NEVER render objects, undefined, null, or non-serializable values directly.
   - **Error Details:**
     - **Error Message:** `Minified React error #130; visit https://reactjs.org/docs/error-decoder.html?invariant=130&args[]=undefined&args[]=`
     - **Root Cause:** Rendering `undefined`, `null`, objects, or non-serializable values as React children
     - **Chakra UI Impact:** All Chakra UI components (`Text`, `Heading`, `Badge`, `Box`, etc.) expect valid React children per React's children prop rules
     - **Reference:** Chakra UI Style Props documentation - components follow standard React children prop behavior
   
   - **Type Safety for API Data (MANDATORY):**
     - When rendering content from API responses or state, ALWAYS ensure it's a string/number before rendering:
     - ‚ùå WRONG: `<Text>{message.content}</Text>` - if `content` could be undefined/object/null
     - ‚ùå WRONG: `<Badge>{conversation.status}</Badge>` - if status could be undefined
     - ‚ùå WRONG: `<Text>{entry.thought}</Text>` - if thought could be undefined/object
     - ‚úÖ CORRECT: `<Text>{typeof message.content === 'string' ? message.content : String(message.content || '')}</Text>`
     - ‚úÖ CORRECT: `<Badge>{typeof conversation.status === 'string' ? conversation.status : String(conversation.status || 'unknown')}</Badge>`
     - ‚úÖ CORRECT: `<Text>{typeof entry.thought === 'string' ? entry.thought : String(entry.thought || '')}</Text>`
   
   - **API Response Validation (MANDATORY):**
     - When loading data from APIs, validate and convert types immediately:
     - ‚ùå WRONG: `content: msg.content` - assumes API returns correct type
     - ‚ùå WRONG: `title: session.title` - assumes title is always a string
     - ‚úÖ CORRECT: `content: typeof msg.content === 'string' ? msg.content : String(msg.content || '')`
     - ‚úÖ CORRECT: `title: typeof session.title === 'string' ? session.title : String(session.title || 'New Session')`
   
   - **State Access Safety (MANDATORY):**
     - Always validate data types when accessing nested state or computed values:
     - ‚ùå WRONG: `{session.title}` - if title could be undefined
     - ‚ùå WRONG: `{transformThought(entry.thought)}` - if transformThought might return undefined
     - ‚ùå WRONG: `{formatDate(conversation.completedAt)}` - if date is invalid
     - ‚úÖ CORRECT: `{typeof session.title === 'string' ? session.title : String(session.title || '')}`
     - ‚úÖ CORRECT: Ensure helper functions always return strings:
       ```tsx
       const transformed = transformThought(entry.thought);
       <Text>{typeof transformed === 'string' ? transformed : String(transformed || '')}</Text>
       ```
     - ‚úÖ CORRECT: Validate dates before formatting:
       ```tsx
       const formatDate = (date: Date | undefined | null): string => {
         if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
           return 'Unknown date';
         }
         return date.toLocaleDateString();
       };
       ```
   
   - **Chakra UI Component Props:**
     - All Chakra UI text components follow React's children prop rules
     - Conditional rendering with `{value && <Text>{value}</Text>}` is safe ONLY if value is validated first
     - For dynamic content, ALWAYS validate before passing to Chakra components
     - Reference: Chakra UI documentation - Style Props and Component API follow standard React patterns
   
   - **Common Failure Points:**
     * Rendering API response values without validation
     * Rendering Zustand store values that might be undefined during loading
     * Rendering computed/transformed values from helper functions
     * Rendering object properties accessed with optional chaining
     * Rendering values from `useMemo` or `useCallback` that might return undefined
   
   - **Why?** React Error #130 occurs when objects/undefined/null are rendered as children. TypeScript types don't guarantee runtime values match, especially with:
     * API responses that may have different structures than expected
     * State that might be partially loaded or in transition
     * Helper functions that might return undefined for edge cases
     * Optional chaining that returns undefined (`entry?.thought`)

18. **No Zustand actions in useEffect dependencies (Prevents React Error #310)**: Zustand action functions are stable references and MUST NOT be included in `useEffect` dependency arrays. This causes infinite re-render loops.
   - **Zustand Actions are Stable**: Action functions from Zustand slices never change between renders, so they don't need to be in dependencies.
   - ‚ùå WRONG: `useEffect(() => { loadMessages(sessionId); }, [sessionId, loadMessages])` - `loadMessages` causes infinite loops
   - ‚úÖ CORRECT: `useEffect(() => { loadMessages(sessionId); }, [sessionId])` - Only include state values, not action functions
   - ‚úÖ CORRECT: Use `eslint-disable-next-line react-hooks/exhaustive-deps` with a comment explaining why:
     ```tsx
     useEffect(() => {
       if (sessionId && messages.length === 0) {
         loadMessages(sessionId);
       }
       // eslint-disable-next-line react-hooks/exhaustive-deps
     }, [sessionId, messages.length]); // loadMessages is stable from Zustand, no need in deps
     ```
   - **When to Include**: Only include primitive values, arrays, or objects that should trigger re-runs. Zustand selectors that return primitives are fine: `[sessionId, messages.length]`
   - **Why?** React Error #310 occurs when hooks are called with changing dependencies that cause infinite loops. Zustand actions are stable but including them tricks React into thinking dependencies changed.

19. **No missing tabId in callRPC() calls (Prevents tab switching bugs)**: ALL `callRPC()` calls that target the current task's tab MUST pass `tabId` explicitly. Without it, the function queries the "active" tab which may be wrong when the user switches tabs.
   - ‚ùå WRONG: `await callRPC('getAnnotatedDOM', [], 5)` - Will send message to wrong tab
   - ‚ùå WRONG: `await getInteractiveElementSnapshot()` - Missing tabId
   - ‚ùå WRONG: `await waitForDOMChangesAfterAction(snapshot, config)` - Missing tabId
   - ‚úÖ CORRECT: `await callRPC('getAnnotatedDOM', [], 5, tabId)`
   - ‚úÖ CORRECT: `await getInteractiveElementSnapshot(tabId)`
   - ‚úÖ CORRECT: `await waitForDOMChangesAfterAction(snapshot, config, tabId)`
   - **Why?** When users switch tabs and start a new task, the extension must target the correct tab. Without explicit `tabId`, Chrome extension APIs may target the previously active tab.
   - **Reference:** `docs/CLIENT_ARCHITECTURE.md` ¬ß12.4 (Tab Switching Breaks Content Script Communication)

20. **No missing keep-alive for long-running operations (Prevents Service Worker death)**: ANY operation that might take longer than 25 seconds MUST be wrapped with `startKeepAlive()` / `stopKeepAlive()`. Chrome's Manifest V3 terminates Service Workers after 30 seconds of inactivity.
   - ‚ùå WRONG: `const response = await apiClient.agentInteract(...)` - No keep-alive
   - ‚úÖ CORRECT:
     ```typescript
     startKeepAlive();
     try {
       const response = await apiClient.agentInteract(...);
     } finally {
       stopKeepAlive();
     }
     ```
   - **Why?** LLM API calls often take 30-60 seconds. Without keep-alive, the Service Worker dies and the response is lost.
   - **Reference:** `docs/CLIENT_ARCHITECTURE.md` ¬ß12.1 (Service Worker Death)

21. **No stale taskId on new tasks (Prevents task confusion)**: When starting a NEW task (not resuming), ALWAYS clear old taskId from `chrome.storage` before proceeding. Otherwise, the extension sends a stale taskId and the server returns "Task already failed".
   - ‚ùå WRONG: Start new task without clearing storage
   - ‚úÖ CORRECT:
     ```typescript
     if (isNewTask) {
       await chrome.storage.local.remove([`task_${tabId}`, 'active_task_state']);
     }
     ```
   - **Why?** Chrome storage persists across page navigations. Old task state must be cleared to prevent confusion.
   - **Reference:** `docs/CLIENT_ARCHITECTURE.md` ¬ß12.7 (Stale taskId After Task Failure)

22. **No DOM access without null guards (Prevents navigation crashes)**: In content scripts, ALWAYS check for `document.documentElement` and `document.readyState` before accessing the DOM. After navigation, the DOM may not be ready yet.
   - ‚ùå WRONG: `const clone = document.documentElement.cloneNode(true)` - May crash if null
   - ‚úÖ CORRECT:
     ```typescript
     if (!document.documentElement || document.readyState === 'loading') {
       return null; // Signal to caller to retry
     }
     const clone = document.documentElement.cloneNode(true);
     ```
   - **Why?** After navigation, content scripts may execute before the DOM is ready, causing "Cannot read properties of null" errors.
   - **Reference:** `docs/CLIENT_ARCHITECTURE.md` ¬ß12.5 (Navigation Timing)

23. **No missing host_permissions in manifest (Prevents script injection failures)**: For `chrome.scripting.executeScript()` to work in Manifest V3, the manifest MUST include `host_permissions`. Without it, programmatic content script injection fails silently.
   - ‚ùå WRONG: Manifest with only `permissions: ["scripting"]`
   - ‚úÖ CORRECT:
     ```json
     {
       "permissions": ["scripting", ...],
       "host_permissions": ["http://*/*", "https://*/*"]
     }
     ```
   - **Why?** MV3 requires explicit host permissions for script injection. Content script auto-injection uses `content_scripts.matches`, but programmatic injection needs `host_permissions`.
   - **Reference:** `docs/CLIENT_ARCHITECTURE.md` ¬ß12.6 (Programmatic Script Injection)

---

## 11. Implementation Checklist

*Before outputting code, verify:*

**Architecture:**
- [ ] Code is appropriate for Chrome Extension (not Next.js/web app)
- [ ] Correct file location (pages/ vs common/ vs helpers/)
- [ ] Proper Chrome API usage with error handling
- [ ] Content script vs background vs UI page context understood
- [ ] **tabId passed to all callRPC() calls** - prevents tab switching bugs
- [ ] **Keep-alive wrapper for long operations** - prevents Service Worker death
- [ ] **DOM null guards in content scripts** - prevents navigation crashes
- [ ] **Storage cleared on new task** - prevents stale taskId issues

**TypeScript:**
- [ ] All functions have explicit types
- [ ] No `any` types (use `unknown` for errors)
- [ ] File extension correct (.tsx for JSX, .ts for pure TS)
- [ ] Type guards used instead of assertions when possible

**React & Chakra UI:**
- [ ] Functional components with hooks
- [ ] Chakra UI components used (not raw HTML)
- [ ] Zustand store used for global state
- [ ] Selector pattern used for store access
- [ ] **NO object returns from useAppState** - split selectors to prevent infinite loops
- [ ] **ALL colors use useColorModeValue** - no hardcoded colors without dark mode support
- [ ] **Dark mode tested** - component works correctly in both light and dark themes
- [ ] **Color values defined at component top level** - not inside render loops
- [ ] **NO Zustand actions in useEffect deps** - prevents React Error #310 (infinite loops)
- [ ] **ALL rendered values are primitives/React elements** - prevents React Error #130 (invalid children)
- [ ] **API response data validated** - ensure strings/numbers before rendering, never render objects directly
- [ ] **Type guards on ALL JSX interpolations** - `{value}` must be validated: `{typeof value === 'string' ? value : String(value || '')}`
- [ ] **Helper functions return strings** - `transformThought()`, `formatDate()`, etc. must always return strings, never undefined
- [ ] **Chakra UI children validated** - All Chakra components (`Text`, `Badge`, `Heading`, etc.) receive validated children per React rules

**Action System:**
- [ ] New actions added to `availableActions.ts`
- [ ] Action execution implemented correctly
- [ ] Action validation in place
- [ ] Error handling for failed actions

**DOM & LLM:**
- [ ] DOM simplification patterns followed
- [ ] LLM response format correct (`<Thought>` and `<Action>` tags)
- [ ] Token efficiency considered
- [ ] Error handling for LLM failures

**Code Quality:**
- [ ] ESLint rules followed
- [ ] Prettier formatting applied
- [ ] No console.logs in production code (use proper logging)
- [ ] Comments explain "why" not "what"

**Testing:**
- [ ] Unit tests added for new utilities
- [ ] Test cases cover edge cases
- [ ] Tests pass locally

**Extension Specific:**
- [ ] Chrome API errors handled
- [ ] Permissions checked before API calls
- [ ] Message passing used correctly
- [ ] Storage API used for persistence

---

## 12. Common Patterns Reference

### Zustand Store Access

```tsx
// ‚úÖ CORRECT - Split selectors (prevents infinite loops)
const value = useAppState((state) => state.settings.value);
const action = useAppState((state) => state.settings.actions.setValue);

// ‚úÖ CORRECT - Multiple values using split selectors + useMemo
import { useMemo } from 'react';
const value = useAppState((state) => state.settings.value);
const other = useAppState((state) => state.ui.other);
const combined = useMemo(() => ({ value, other }), [value, other]);

// ‚ùå WRONG - Returning object from selector (causes infinite loops!)
const state = useAppState((state) => ({
  value: state.settings.value,
  other: state.ui.other,
}));

// ‚ùå WRONG - Accessing entire store
const store = useAppState(); // Don't do this
```

### Chrome API Error Handling

```typescript
// ‚úÖ CORRECT
chrome.tabs.query({ active: true }, (tabs) => {
  if (chrome.runtime.lastError) {
    console.error('Error:', chrome.runtime.lastError.message);
    return;
  }
  // Use tabs
});

// ‚úÖ CORRECT - Promise-based
const tabs = await chrome.tabs.query({ active: true });
if (chrome.runtime.lastError) {
  throw new Error(chrome.runtime.lastError.message);
}
```

### Action Execution Pattern

```typescript
// ‚úÖ CORRECT
const parsed = parseResponse(llmResponse);
if ('error' in parsed) {
  // Handle error
  return;
}

const { parsedAction } = parsed;
switch (parsedAction.name) {
  case 'click':
    await executeClick(tabId, parsedAction.args.elementId);
    break;
  case 'setValue':
    await executeSetValue(tabId, parsedAction.args.elementId, parsedAction.args.value);
    break;
  default:
    throw new Error(`Unknown action: ${parsedAction.name}`);
}
```

### Content Script Communication

```typescript
// ‚úÖ CORRECT - From UI to Content Script
const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
chrome.tabs.sendMessage(tab.id!, { type: 'ACTION', payload: data });

// ‚úÖ CORRECT - From Content Script to Background
chrome.runtime.sendMessage({ type: 'RESULT', payload: data });
```

### Dark Mode Color Patterns

```tsx
// ‚úÖ CORRECT - Complete component with dark mode support
import { Box, Text, useColorModeValue } from '@chakra-ui/react';

const MyComponent = () => {
  // Define all colors at component top level
  const containerBg = useColorModeValue('white', 'gray.900');
  const cardBg = useColorModeValue('gray.50', 'gray.800');
  const textColor = useColorModeValue('gray.900', 'gray.100');
  const descColor = useColorModeValue('gray.600', 'gray.400');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  const hoverBg = useColorModeValue('gray.100', 'gray.700');
  
  return (
    <Box bg={containerBg} p={4}>
      <Box
        bg={cardBg}
        borderWidth="1px"
        borderColor={borderColor}
        borderRadius="md"
        p={4}
        _hover={{ bg: hoverBg }}
      >
        <Text color={textColor} fontSize="lg" fontWeight="bold">
          Title
        </Text>
        <Text color={descColor} fontSize="sm">
          Description text
        </Text>
      </Box>
    </Box>
  );
};

// ‚úÖ CORRECT - Using _dark prop for component-specific overrides
<Box
  bg="white"
  _dark={{ bg: 'gray.800' }}
  borderColor="gray.200"
  _dark={{ borderColor: 'gray.700' }}
>
  <Text color="gray.700" _dark={{ color: 'gray.300' }}>
    Text
  </Text>
</Box>

// ‚ùå WRONG - Hardcoded colors without dark mode
<Box bg="white" color="gray.900">
  <Text color="gray.600">Text</Text>
</Box>

// ‚ùå WRONG - useColorModeValue inside render loop
{items.map(item => (
  <Box bg={useColorModeValue('white', 'gray.800')}>
    {item.name}
  </Box>
))}
```

---

**Priority Order for References:**
1. **This file** - Production rules and patterns
2. **AGENTS.md** - General AI assistant guidelines
3. **CLAUDE.md** - Claude-specific context
4. **Chrome Extension Documentation** - Official Chrome Extension APIs
5. **Chakra UI Documentation** - Component library reference

**When guidelines conflict, prioritize this file for code patterns and Chrome Extension best practices.**
